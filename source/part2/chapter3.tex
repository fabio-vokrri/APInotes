\chapter{Strutture Dati}
Gli insiemi manipolati dagli algoritmi, a differenza di quelli matematici, possono essere modificati inserendo o rimuovendo elementi. Questi insiemi sono detti dinamici e giocano un ruolo importante in informatica, perchè modellano le strutture utilizzate per memorizzare in modo ordinato i dati.

In una tipica implementazione di un insieme dinamico, ogni elemento è rappresentato da un oggetto, i cui attributi possono essere esaminati e manipolati a piacimento dagli algoritmi. In molte strutture dati, l'oggetto dispone di una chiave identificativa (spesso univoca, ma non necessariamente) e ovviamente di dati satelliti che si vogliono memorizzare ordinatamente in memoria. Oltre a questi due attributi, l'oggetto può anche contenere altri dati specifici per una determinata struttura dati, in modo da rendere più semplice e veloce la loro manipolazione.

Le tipiche operazioni che si possono svolgere sulle strutture dati sono suddivise in due categorie: le query (interrogazioni), che hanno il solo scopo di estrapolare informazioni dall'insieme dinamico, e le operazioni di modifica, che hanno il compito di modificare l'insieme. Di seguito sono elencate le istruzioni più comuni:

\begin{itemize}
  \item \code{search(S, k)}: è un'operazione di query che, dato un insieme \(S\) e un valore chiave \(k\), restituisce \code{NIL} se tale elemento non appartiene all'insieme.
  \item \code{insert(S, x)}: è un'operazione di modifica che inserisce all'interno dell'insieme \(S\) l'elemento puntato da \(x\).
  \item \code{delete(S, x)}: è un'operazione di modifica che, dato un puntatore \(x\) ad un elemento dell'insieme \(S\), rimuove \(x\) da \(S\).
  \item \code{minimum(S)}: è un'operazione di query che ritorna l'elemento dell'insieme \(S\) con la chiave più piccola.
  \item \code{maximum(S)}: è un'operazione di query che ritorna l'elemento dell'insieme \(S\) con la chiave più grande.
  \item \code{successor(S, x)}: è un'operazione di query che, dato un elemento \(x\) la cui chiave appartiene ad un insieme totalmente ordinato \(S\), restituisce un puntatore all'elemento successivo più grande di \(S\) oppure \code{NIL} se \(x\) è il più grande degli elementi.
  \item \code{predecessor(S, x)}: è un'operazione di query che, dato un elemento \(x\) la cui chiave appartiene ad un insieme totalmente ordinato \(S\), restituisce un puntatore all'elemento precedente più piccolo di \(S\) oppure \code{NIL} se \(x\) è il più piccolo degli elementi.
\end{itemize}

\section{Stack}
Gli \textbf{stack} sono insiemi dinamici dove l'elemento da rimuovere tramite l'operazione \code{delete} è predeterminato. In questa struttura dati, l'elemento cancellato è quello inserito per ultimo, secondo la politica LIFO (Last In, First Out). Nello specifico, le operazioni di \code{insert} e \code{delete} prendono rispettivamente il nome di \code{push} e \code{pop} \footnote{Questa operazione non prende nessun argomento, in quanto l'elemento da eliminare è predeterminato}: la prima inserisce in cima alla pila l'elemento passato come argomento, mentre la seconda operazione elimina l'unico elemento accessibile dalla pila, ovvero la cima. 

Questa struttura dati può essere implementata tramite un array con un massimo di \(n\) elementi \code{S[1..n]}, che presenta lo specifico atrtibuto \code{S.top}, ovvero l'indice tramite cui accedere all'ultimo elemento inserito. L'array è dunque composto dagli elementi \code{S[1..S.top]}, dove \code{S[1]} rappresenta l'elemento in fondo alla pila, mentre \code{S[S.top]} rappresenta l'elemento in cima. Ovviamente, se \code{S.top} = 0, si dice che la pila è vuota, in quanto non contiene nessun elemento. In questo caso, se si tenta di estrarre un elemento dallo stack, si ottiene un errore di underflow dello stack, mentre se si cerca di inserire un elemento sulla pila piena (che conta quindi di \(n\) elementi), si ottiene un errore di overflow dello stack.

Le operazioni dello stack possono essere implementate molto semplicemente in pseudocodifica come segue:

\begin{lstlisting}
push(S, x):
  if S.top = S.length:
    error "overflow"
  else:
    S.top := S.top + 1
    S[S.top] := x
\end{lstlisting}

\begin{lstlisting}
pop(S):
  if iS.top = 0:
    error "underflow"
  else:
    S.top := S.top - 1
    return S[S.top + 1]
\end{lstlisting}

Si noti come, in questo caso, l'operazione di \code{pop} ritorna l'elemento appena eliminato dallo stack. Entrambe le procedure vengono eseguite in tempo costante \(\Theta(1)\).

\section{Queue}
Le \textbf{code} sono insiemi dinamici dove l'elemento da rimuovere tramite l'operazione \code{delete} è predeterminato. In questa struttura dati, l'elemento cancellato è quello inserito per primo, secondo la politica FIFO (First In First Out). Nello specifico, la coda presenta un inizio detto \code{head} e una fine detta \code{tail}, e le operazioni di \code{insert} e \code{delete} prendono rispettivamente il nome di \code{enqueue} e \code{dequeue} \footnote{Anche in questo caso, questa operazione non prende nessun argomento, in quanto l'elemento da eliminare è predeterminato}: la prima inserisce in fondo alla fila l'elemento passato come argomento, mentre la seconda operazione elimina il primo elemento della fila. 

Questa struttura dati può essere implementata tramite un array di \(n\) elementi \code{Q[1..n]}, che contiene un massimo di \(n-1\) elementi, per ragioni che verranno chiarite in seguito. L'attributo \code{Q.head} punta all'inizio della coda, mentre l'attributo \code{Q.tail} punta alla posizione in cui l'ultimo elemento che dovrà essere inserito prenderà posto (ovvero alla posiziove vuota successiva all'ultimo elemento della coda). Gli elementi della coda, quindi, occupano le posizioni \code{Q.head}, \code{Q.head + 1}, ..., \code{Q.tail - 1}. Alla fine dell'array la posizione 1 della queue segue immediatamete la posizione \(n\) secondo un ordine circolare. Se \code{Q.head = Q.tail} allora la coda è vuota. All'inizio le posizioni \code{Q.head} e \code{Q.tail} combaciano e sono entrambe inizializzate al valore 1.

Come per gli stack, se la coda è vuota, il tentativo di rimuovere un elemento provoca un errore di underflow, mentre se \code{Q.head = Q.tail + 1} la coda è piena e il tentativo di inserire un nuovo elemento provoca un errore di overflow. 

Le operazioni della queue possono essere implementate molto semplicemente in pseudocodifica come segue:

\begin{lstlisting}
enqueue(Q, x):
  Q[Q.tail] := x
  if Q.tail = Q.length:
    Q.tail := 1
  else:
    Q.tail := Q.tail + 1
\end{lstlisting}

\begin{lstlisting}
dequeue(Q, x):
  x := Q[Q.head]
  if Q.head = Q.length:
    Q.head := 1
  else:
    Q.head := Q.head + 1
  return x
\end{lstlisting}

Entrambe le procedure vengono eseguite in un tempo costante \(\Theta(1)\).

\section{Linked List}
Una \textbf{lista concatenata} è una struttura dati i cui oggetti sono disposti in ordine lineare, determinato da un puntatore in ogni oggetto. Una lista doppiamente concatenata è una lista in cui ogni oggetto presenta, oltre ad una chiave \code{key}, anche un puntatore all'elemento successivo \code{next} e un puntatore a quello precedente \code{prev}. Se \code{x.prev = NIL}, allora l'elemento \(x\) è il primo elemento della lista e si dice essere la testa (o head) della lista. Se, invece, \code{x.next = NIL}, allora \(x\) è l'ultimo elemento della lista e si dice essere la coda (o tail) della lista. Intuitivamente, l'attributo \code{L.head} punta alla testa della lista, che sarà vuota se \code{L.head = NIL}.

Questa struttura dati può presentare varie forme: può essere doppiamente concatenata o singolarmente concatenata, oppure può essere circolare o non. Una lista si dice singolarmente concatenata se i suoi oggetti non sono dotati di puntatore all'elemento precedente, mentre si dicono circolari se l'ultimo elemento possiede un puntatore alla testa della lista, che a sua volta possiede un puntatore alla coda se la lista è circolare. Una lista concatenata può anche essere ordinata o non: si dice ordinata quando la disposizione lineare degli elementi corrisponde con la disposizione crescente delle chiavi degli elementi e, in tal caso, la testa della lista conterrà l'elemento minimo, mentre la coda l'elemento massimo. 

Nel seguito si fa riferimento a liste non ordinate doppiamente concatenate per lo sviluppo degli algoritmi che le manipolano. 

\vspace{10pt}

La prima procedura che sia analizza è \code{listSearch(L, k)}, che trova il primo elemento con la chiave \(k\) nella lista \(L\), restituendo un puntatore a tale oggetto. Se nessun oggetto con chiave \(k\) è presente nella lista, allora viene restituito il valore \code{NIL}. In pseudocodifica:

\begin{lstlisting}
listSearch(L, k):
  x := L.head
  while x != NIL and x.key != key:
    x := x.next
  return x  
\end{lstlisting}

Si noti quindi che l'algoritmo \code{listSearch} cerca l'elemento di chiave \(k\) tramite una ricerca lineare sulla list \(L\) di \(n\) elementi. Dunque, l'algoritmo impiega un tempo \(\Theta(n)\) nel caso peggiore, in quanto potrebbe essere necessario scorrere l'intera lista.

\vspace{10pt}

La seconda procedura analizzata è \code{listInsert(L, x)} che inserisce l'elemento x di attributo key (già inizializzato) in testa alla lista. In pseudocodifica:

\begin{lstlisting}
listInsert(L, x):
  x.next := L.head
  if L.head != NIL:
    L.head.prev := x
  L.head := x
  x.prev := NIL 
\end{lstlisting}

Questa procedura impiega un tempo costante \(\Theta(1)\) per la sua esecuzione.

\vspace{10pt}

L'ultima procedura analizzata per le linked list è \code{listDelete(L, x)}, che rimuove l'elemento \(x\) dalla lista \(L\). Per poter eliminare tale elemento è prima necessario chiamare la funzione \code{listSearch} per ottenere il puntatore all'elemento desiderato. In pseudocodifica:

\begin{lstlisting}
listDelete(L, x):
  if x.prev != NIL:
    x.prev.next := x.next
  else:
    L.head := x.next
  if x.next != NIL:
    x.next.prev := x.prev
\end{lstlisting}

Anche questa procedura impiega un tempo di esecuzione \(\Theta(1)\).

\section{Tavole Hash}

% \section{Alberi Binari}
% \section{Alberi RB}
% \section{Grafi}
